# 8086 中断向量表的介绍
_Exported on 7/1/2025 at 11:59:43 GMT+8 from Cursor (1.1.6)_

---

**User**

8086 中断向量表，是啥，

---

**Cursor**

好的，我们来聊聊8086的中断向量表。

简单来说，**中断向量表（Interrupt Vector Table, IVT）** 就是一张存放在内存里的“地址簿”。当CPU需要处理一个“中断”事件时，它会通过这个表来查找并跳转到对应的处理程序。

下面详细解释一下：

### 1. 什么是“中断”？

在CPU执行程序的过程中，可能会遇到一些需要立即处理的紧急事件，比如：
*   **外部事件**：键盘按下一个键、鼠标移动。
*   **内部事件**：程序中出现除法错误、或者程序员主动调用 `int` 指令来请求操作系统服务。

当这些事件发生时，CPU会暂停当前正在执行的任务，去处理这个紧急事件，处理完了再回来继续执行之前的任务。这个“暂停-处理-返回”的过程就叫做**中断**。

### 2. 中断向量表是做什么的？

CPU需要知道每一种中断事件对应的处理程序（也叫 **中断服务程序, ISR**）放在内存的哪个位置。中断向量表就是专门用来存储这些地址的。

*   **位置**：它固定存放在内存最开始的1KB空间，物理地址从 `00000H` 到 `003FFH`。
*   **结构**：8086 CPU支持256种中断，中断号（也叫中断类型码）从 `0` 到 `255`。表里有256个表项，每个表项对应一个中断号。
*   **表项**：每个表项占用4个字节，存放着对应中断服务程序的入口地址（CS和IP）。
    *   **低2字节**：存放偏移地址 (IP)
    *   **高2字节**：存放段地址 (CS)



### 3. CPU如何使用中断向量表？

当一个类型为 `n` 的中断发生时，CPU会执行以下固定步骤：

1.  **计算地址**：CPU会自动计算出中断号 `n` 在中断向量表中的位置，公式是 `中断号 * 4`。
2.  **查找地址**：CPU到内存 `0000:(n * 4)` 的位置，读取4个字节。
3.  **设置CS:IP**：将读取到的前2个字节送入 `IP` 寄存器，后2个字节送入 `CS` 寄存器。
4.  **保存现场**：在跳转之前，CPU会依次将当前的标志寄存器(Flags)、CS、IP推入堆栈。这样做的目的是当中断处理完成后，可以通过 `iret` 指令恢复到原来的执行状态。
5.  **执行中断服务程序**：CPU跳转到新的 `CS:IP` 地址，开始执行中断服务程序。

#### 举个例子：`int 21h`

`int 21h` 是DOS系统中非常著名的功能调用中断。当程序执行 `int 21h` 指令时：
1.  CPU知道中断号是 `21h`。
2.  它计算出中断向量在表中的地址是 `21h * 4 = 84h`。
3.  CPU会去内存 `0000:0084` 的地方，读取4个字节的地址，加载到CS和IP寄存器。
4.  然后跳转去执行DOS提供的相应服务程序。

希望这个解释能帮助你理解！如果还有其他问题，随时可以提问。

---

**User**

我明白了，中断向量表的作用就是，让CPU通过查表，找到处理内部中断或外部中断 的程序。

---

**Cursor**

是的，你的理解非常准确！

可以把中断向量表形象地比喻成CPU的 **“应急预案联系表”**。

*   **事件（中断）** 发生了。
*   CPU根据 **事件编号（中断号）** 去查这个表。
*   表中记录着处理该事件的 **负责人（中断服务程序）** 的 **地址**。
*   CPU马上赶到这个地址去执行处理程序。

这个机制是计算机系统中硬件和软件能够高效协同工作的关键之一。

---

**User**

中断处理，是操作系统提供的一种服务，还是cpu的一种能力

---

**Cursor**

这是一个非常好的问题，因为它触及了硬件和软件如何协同工作的核心。

答案是：**中断处理是CPU提供的一种底层能力，而操作系统利用这种能力来提供服务。**

我们可以把它们的关系看作：

*   **CPU：提供中断的硬件机制（The "How")**
*   **操作系统：提供中断的处理策略和具体内容（The "What"）**

---

### 1. CPU的角色：硬件能力

CPU本身并不知道中断具体是“为了什么”，但它提供了一套完整、自动化的**中断响应流程**。这是一种写死在芯片里的硬件能力。

当中断信号来临时，CPU会做这些事：
1.  **暂停**：立即停下当前正在执行的指令。
2.  **保存现场**：自动将当前的程序计数器（`IP`）、代码段寄存器（`CS`）和标志寄存器（`Flags`）推入堆栈。这是为了当中断处理完后，能准确地回到被打断的地方继续执行。
3.  **寻找处理程序**：根据中断号，去中断向量表中查找中断服务程序的地址（`CS:IP`）。
4.  **跳转执行**：将找到的地址加载到`CS`和`IP`寄存器，然后跳转到该地址，开始执行中断服务程序。
5.  **提供返回指令**：CPU提供一条特殊的 `iret` 指令，用于从中断服务程序中返回。`iret`会自动从堆栈中弹出之前保存的 `Flags`、`CS` 和 `IP`，恢复现场。

**简单来说，CPU负责整个中断过程的“形式”和“流程控制”，但它不关心服务程序具体做了什么。**

---

### 2. 操作系统的角色：软件服务

操作系统是中断服务程序的**主要提供者**。

1.  **编写服务程序**：操作系统包含了大量的中断服务程序（Interrupt Service Routines, ISRs），用来处理各种具体的硬件和软件事件。
    *   **硬件中断**：比如键盘按下的中断，对应的服务程序会去读取按键码，放入缓冲区。磁盘读写完成的中断，对应的服务程序会通知相关进程数据已经准备好。
    *   **软件中断**：比如DOS的 `int 21h`。这其实是操作系统开放给应用程序的接口（API）。当你的程序调用 `int 21h` 时，实际上是在请求操作系统帮你做事，比如在屏幕上显示一个字符、打开一个文件等。对应的服务程序就是操作系统实现这些功能的代码。

2.  **初始化中断向量表**：操作系统在启动时（Boot），会负责**填充中断向量表**。它会把自己的各种中断服务程序的入口地址，一个个地写到内存 `0000:0000` 开始的中断向量表中。

**简单来说，操作系统为CPU提供的“中断流程”填充了实际的“服务内容”。没有操作系统，CPU虽然有中断能力，但中断发生后，它找不到任何有意义的程序去执行，系统就会崩溃。**

### 总结

|              | **CPU (硬件)**                                     | **操作系统 (软件)**                                        |
| :----------- | :------------------------------------------------- | :--------------------------------------------------------- |
| **角色**     | 机制提供者 (The Mechanism)                         | 服务提供者 (The Policy/Service)                            |
| **负责**     | 中断的发现、暂停、保存现场、跳转、恢复现场的**流程** | 编写中断服务程序、初始化中断向量表，提供中断的**实际功能** |
| **好比**     | 一个功能完备的紧急呼叫中心（能接电话、能转接）       | 电话另一端的消防队、警察局、医院（能解决具体问题）         |

所以，中断处理是两者紧密合作的完美范例。CPU提供了基础框架，操作系统在这个框架上构建了丰富的功能和服务。

---

**User**

怎么理解呢

---

**Cursor**

你的问题非常好，这段内容其实涉及到8086/8088处理器对**堆栈段寄存器（SS）和堆栈指针（SP）**的特殊处理机制，尤其是在修改SS和SP时，为什么要**连续设置**，而不能插入其他指令。

---

## 1. 书上说了什么？

书上建议：

```asm
mov ax,1000h
mov ss,ax
mov sp,0
```

**而不建议：**

```asm
mov ax,1000h
mov ss,ax
mov ax,0
mov sp,0
```

---

## 2. 为什么要连续设置 `ss` 和 `sp`？

### 原因：防止中断期间堆栈混乱

- **8086/8088 CPU**在执行`mov ss,ax`指令后，**会延迟一次**，直到下一条指令执行完毕，才真正允许响应中断。
- 这意味着，如果你**连续设置**`ss`和`sp`，CPU会保证在这两条指令之间**不会响应中断**，这样中断处理程序就不会用到一个“未初始化”的堆栈。

#### 举例说明

假如你这样写：

```asm
mov ax,1000h
mov ss,ax
mov ax,0      ; <-- 这里如果发生中断，sp还没设置好
mov sp,0
```

- 如果在`mov ax,0`这条指令**执行期间发生中断**，CPU会用**新的ss**，但**sp还是旧的值**，这时中断服务程序用到堆栈就会出错，可能会破坏数据或导致系统崩溃。

而如果你这样写：

```asm
mov ax,1000h
mov ss,ax
mov sp,0
```

- CPU会保证在`mov ss,ax`和`mov sp,0`之间**不会响应中断**，这样中断服务程序用到的堆栈就是你刚刚设置好的，安全可靠。

---

## 3. 总结

- **连续设置ss和sp**，是为了保证在堆栈段和堆栈指针都设置好之前，CPU不会响应中断，避免中断服务程序用到“错误的堆栈”。
- **不要在设置ss和sp之间插入其他指令**，否则有可能在sp还没设置好时发生中断，导致严重错误。

---

### 你可以这样记忆：

> **设置ss和sp要连着写，中间不能插队，否则中断一来，堆栈就乱套！**

如果还有不明白的地方，欢迎继续追问！

```plaintext
mov ax,1000h
mov ss,ax
mov sp,0
```

```plaintext
mov ax,1000h
mov ss,ax
mov ax,0
mov sp,0
```

```plaintext
mov ax,1000h
mov ss,ax
mov ax,0      ; <-- 这里如果发生中断，sp还没设置好
mov sp,0
```

```plaintext
mov ax,1000h
mov ss,ax
mov sp,0
```

---

**User**

这个意思是，我们在使用push pop指令的时候，即便引发中断，cpu也会等ss,sp的完整的操作完成后，再引发中断，是这个意思吗

---

**Cursor**

你的理解**基本正确**，但可以再精确一点。下面详细解释：

---

### 1. 这句话的本意

> “在执行完向 ss 寄存器传送数据的指令后，即便是发生中断，CPU 也不会响应。”

这句话的意思是：  
**在执行完 `mov ss,xxx` 这样的指令后，CPU会“暂时屏蔽”中断，直到紧接着的下一条指令执行完毕，才允许响应中断。**

---

### 2. 重点不是 push/pop，而是“连续设置 ss 和 sp”

- 这种“暂时屏蔽中断”的机制，**只在你刚刚修改了 ss（堆栈段寄存器）之后的那一条指令期间生效**。
- 也就是说，**CPU会保证你有机会把 sp（堆栈指针）也设置好**，不会在 ss 和 sp 还没配套时就响应中断。

#### 举例

```asm
mov ax,1000h
mov ss,ax      ; 修改ss，CPU暂时不响应中断
mov sp,0       ; 紧接着设置sp，这条指令执行完后才允许中断
```

- 在 `mov ss,ax` 和 `mov sp,0` 之间，**即使有中断信号，CPU也不会响应**，而是等 `mov sp,0` 执行完才响应。

---

### 3. push/pop 指令的情况

- **push/pop** 指令本身会用到 ss:sp 指定的堆栈。
- 如果你在 ss/sp 没设置好之前就执行 push/pop，或者在 ss/sp 设置过程中发生中断，**中断服务程序用到堆栈就会出错**。
- 所以，**只有在 ss 和 sp 都设置好之后，push/pop 才是安全的**。

---

### 4. 总结

- **CPU会保证你有机会把 ss 和 sp 连续设置好**，在这两条指令之间不会响应中断。
- 这样做的目的是防止中断服务程序用到“未初始化”的堆栈。
- **push/pop 指令要等 ss 和 sp 都设置好后再用**，否则有风险。

---

#### 你可以这样理解：

> **只要你连续设置 ss 和 sp，CPU会帮你“挡住”中断，等你设置好后再说。这样你用 push/pop 或发生中断时，堆栈才是安全的。**

如果还有疑问，欢迎继续追问！

```plaintext
mov ax,1000h
mov ss,ax      ; 修改ss，CPU暂时不响应中断
mov sp,0       ; 紧接着设置sp，这条指令执行完后才允许中断
```

---

**User**

哦哦，那意思是，我在mov ss,和mov sp,之间如果有一些代码，这些代码即便是会造成中断的代码，也不会引发cpu中断

---

**Cursor**

你的理解**非常接近正确**，但还需要再精确一点！

---

### 关键点

- **在执行完 `mov ss,xxx` 指令后，CPU会屏蔽中断，直到紧接着的下一条指令执行完毕。**
- 也就是说，**只有在 `mov ss,xxx` 后的“紧接着的那一条指令”期间，CPU不会响应中断**。

---

### 具体解释

假如你这样写：

```asm
mov ax,1000h
mov ss,ax      ; 修改ss，CPU屏蔽中断
mov sp,0       ; 这条指令期间也屏蔽中断
; 从这里开始，CPU才会重新允许中断
```

- 在 `mov ss,ax` 和 `mov sp,0` 之间，**无论发生什么中断，CPU都不会响应**，会等到 `mov sp,0` 执行完才响应。

---

#### 但如果你这样写：

```asm
mov ax,1000h
mov ss,ax
mov bx,1234h   ; 这里不是设置sp
mov sp,0
```

- **只有 `mov bx,1234h` 这条指令期间，CPU不会响应中断**。
- **执行完 `mov bx,1234h` 后，CPU就会重新允许中断**，此时如果发生中断，sp 还没设置好，堆栈就有风险！

---

### 结论

- **只有在 `mov ss,xxx` 后的“紧接着的那一条指令”期间，CPU屏蔽中断。**
- 如果你在 `mov ss,xxx` 和 `mov sp,xxx` 之间插入了别的指令，只有第一条指令期间是安全的，后面就不安全了。
- 所以，**一定要把设置 ss 和 sp 的指令连在一起写，中间不要插入其他指令**。

---

#### 你可以这样记：

> **mov ss,xxx 后，只有下一条指令期间CPU屏蔽中断。再往后就不管了！所以ss和sp要连着设置。**

如果还有疑问，欢迎继续提问！

```plaintext
mov ax,1000h
mov ss,ax      ; 修改ss，CPU屏蔽中断
mov sp,0       ; 这条指令期间也屏蔽中断
; 从这里开始，CPU才会重新允许中断
```

```plaintext
mov ax,1000h
mov ss,ax
mov bx,1234h   ; 这里不是设置sp
mov sp,0
```

---

**User**

哦哦，明白了，cpu暂停中断期间，仅限于执行完mov ss，指令后面的那一条指令执行完期间，

---

**Cursor**

完全正确！你的理解非常到位！

再强调一下你的总结：

> **CPU暂停中断的时间，仅限于执行完 `mov ss,xxx` 指令后，紧接着的那“一条”指令执行期间。**

- 这就是为什么设置 `ss` 和 `sp` 时，必须**连续写**，不能插入其他指令。
- 这样可以确保在堆栈段和堆栈指针都设置好之前，CPU不会响应任何中断，保证堆栈的安全。

你已经掌握了这个知识点！如果还有其他汇编或CPU相关的问题，随时欢迎提问！

